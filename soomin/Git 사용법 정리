* Git - 버전관리
git이란 소스코드를 효과적으로 관리하기 위해 개발된 ‘분산형 버전 관리 시스템’
git에서는 소스코드가 변경된 이력을 쉽게 확인할 수 있고, 특정 시점에 저장된 버전과 비교하거나 특정 시점으로 되돌아갈 수 있다.

* Repository
git repository란 파일이나 폴더를 저장해두는 공간. 파일이 변경 이력별로 구분되어 저장된다. 비슷한 파일이라도 실제 내용 일부 문구가 다르면 다른 파일로 인식되어 파일을 변경사항 별로 구분해 저장 가능하다.
저장소를 새로 만들거나 이미 만들어져있는 원격 저장소를 로컬 저장소로 복사함으로서 저장소를 만들 수 있다.

* 원격저장소 & 로컬 저장소
git은 원격 저장소와 로컬 저장소 두 종류의 저장소를 제공한다.
-	원격 저장소(Remote Repository): 파일이 원격 저장소 전용 서버에서 관리되며, 여러 사람이 함께 공유하기위한 저장소
-	로컬 저장소(Local Repository): 내 PC에 파일이 저장되는 개인 전용 저장소

-	push: 다른 사람의 repository를 가져오는 것
-	pull: 내 repository를 올리는 것

* 커밋 – 변경을 기록
파일 및 폴더의 추가/변경 사항을 저장소에 기록하기 위해서 ‘commit’이라는 버튼을 눌러야함
커밋 버튼을 누르면 이전 커밋 상태부터 현재 상태까지의 변경 이력이 기록된 커밋(or 리비전)이 만들어짐
커밋은 시간순으로 저장된다.
커밋에 붙는 고유 이름으로 버그 수정, 기능 추가등.. 의미있는 업데이트를 작업별로 구분해놓으면 좋다.
커밋 버튼을 누를땐 커밋 메시지를 필수로 입력해야한다.

# Git에서 권장하는 메시지 형식
	1: 커밋 내의 변경 내용을 요약
	2: (빈칸)
	3: 변경한 이유

* 작업트리와 인덱스 (Work Tree & Index)
작업트리: git에서는 폴더를 ‘작업트리’라고 부른다.
인덱스: 커밋을 실행하기 전의 저장소와 작업 트리 사이에 존재하는 공간을 ‘인덱스’라고 부른다. (가상공간)
git의 ‘커밋’ 작업은 ‘작업트리’에 있는 변경 내용을 저장소에 바로 기록하는 것이 아니라 그 사이 공간인 ‘인덱스’에 파일 상태를 기록하게 되어있다.(stage-스테이징) 저장소에 변경사항을 기록하기 위해서는 기록하고자 하는 모든 변경사항들이 ‘인덱스’에 존재해야한다.
	인덱스라는 공간이 중간에있기 때문에 작업트리 안에 있는 커밋이 필요 없는 파일들을 커밋에 포함하지 않을 수 있고, 파일에서 내가 원하는 일부 변경사항만 인덱스에 등록해 커밋할 수 있다.

* Push (to 원격 저장소)
웹 상의 원격 저장소로 변경된 파일을 업로드하는 것.
내 PC의 로컬 저장소에서 변경된 이력을 원격 저장소에 공유하려면, 로컬 저장소의 변경 이력을 원격 저장소에 업로드 해야한다. push를 실행하면 원격 저장소 내에 변경 이력이 업로드되어 원격 저장소와 로컬 저장소가 동일한 상태가 된다.

* Clone (원격 저장소 복제)
누군가의 변경 이력이 적용된 원격 저장소가 있으면 그것을 웹에서 통째로 복제해와 내 PC에서 직접 작업할 수 있다. 복제란 원격 저장소의 내용을 통째로 다운로드하는것이다. 복제한 저장소를 다른 PC에서 로컬 저장소로 사용할 수 있다.
변경 이력도 함께 로컬 저장소에 복제되어 오므로, 원래 원격 저장소와 똑같이 이력을 참조하고 커밋을 진행할 수 있다.

* Pull (다운로드)
원격 저장소에서 로컬 저장소로 업데이트 하는 것
다른 사람이 원격 저장소에 올려놓은 변경 내용을 내 로컬 저장소에 적용하는 것
pull을 실행하면, 원격 저장소에서 최신 변경 이력을 다운로드하여 내 로컬 저장소에 그 내용을 적용한다.

* Add
파일과 폴더를 인덱스에 등록한다. (staging area에 넣는다.)
파일을 관리할 수 있게 저장소에 파일을 추가하고 커밋한다.
파일 또는 디렉토리의 경로명을 argument로 받고 만일 디렉토리를 argument로 줄 경우, 그 디렉토리 아래에 있는 모든 파일을 재귀적으로 추가한다.

// 참고 https://backlog.com/git-tutorial/kr/intro/intro1_4.html

------------------------------------------------ Mark Down 정리 --------------------------------------------
파일 확장자: .md
특징: 사용법이 매우 쉽고, 빠르게 문서를 정리할 수 있다. 지원 가능한 플랫폼과 프로그램이 다양하다.
단점: 표준이 없어 사용자마다 문법이 상이, 모든 HTML 마크업을 대신할 수 없다.
<h1>~<h6> : 제목 표현
<em>, <strong>, <del> : 강조
<u>, </u> : 밑줄
* : 이텔릭체 // 보라색
*아악* : 두껍게
~~ : 취소선
<ol>, <ul> : 목록
	-, *, + : 순서가 필요하지 않은 목록
<a>, <http://...> : 링크
<br> : 줄바꿈
‘ ’ : 코드 강조, <pre>, <code>로 변환된다.
‘’’ : 블록 코드 강조
각 기호를 3개 이상 입력(---, ***, ___) : 수평선
> , >>> : 인용문
*강조(볼드체)* // 노란색

# 테이블: 헤더 셀을 구분할 때 3개 이상의 -(hyphen/dash) 기호가 필요합니다.
헤더 셀을 구분하면서 :(Colons) 기호로 셀(열/칸) 안에 내용을 정렬할 수 있습니다.
가장 좌측과 가장 우측에 있는 |(vertical bar) 기호는 생략 가능합니다.
# 이미지, 이미지에 링크, 테이블

------------------------------------------------ Git 명령어 정리 --------------------------------------------
// 참고 https://rogerdudler.github.io/git-guide/index.ko.html

환경 설정
git config --global --list
현재 설정정보 조회할 수 있습니다. --global옵션은 전역설정에 대한 옵션이며 현재 프로젝트에만 적용할때는 주지 않습니다.
git config --global user.name "사용자명"
사용자명을 등록합니다 (필수)
git config --global user.email "이메일주소"
이메일 주소를 등록합니다. (필수)
git config --global color.ui “auto”
터미널에 표시되는 메시지에 칼라를 표시해줌

사전지식
git의 저장소는 3가지 단계로 나누어 집니다. 커밋한 소스가 보관되는 저장소와 현재 프로젝트 파일들이 있는 작업트리, 저장소와 작업트리사이의 버퍼영역으로 커밋될 대상이 저장되는 스테이징 영역입니다.
git은 빈 디렉토리는 추적하지 않습니다.
형상관리를 하지 않을 파일은 .gitignore 파일에 추가합니다.
HEAD는 현재 브랜치의 가장 최신커밋을 의미한다.
기본원격 저장소를 origin이라고 부릅니다.


기본적인 명령어
git --version
현재 git의 버전을 확인합니다.

git init
현재 디렉토리에 git 저장소를 생성합니다.

git add 파일명
git add는 2가지를 하는데 untracked files의 파일들을 git가 추적하도록 하거나 파일은 수정했지만 아직 스테이징 영역에 올라가지 않은(Changed but not updated) 파일들을 스테이징 영역에 올립니다. -i 옵션을 주면 대화형모드가 시작되며 파일의 일부분만 선택해서 스테이징하는 것이 가능합니다. -p 옵션을 사용하면 -i 대화형모드없이 바로 패치모드를 사용할 수 있습니다.

git commit -m "커밋메시지"
스테이징 영역에 올라가 있는 파일들을 커밋합니다. -m 은 커밋메시지를 주는 옵션으로 여러 줄의 커밋메시지를 쓸 경우 -m 을 여러개 사용할 수 있습니다. -a 옵션을 사용하면 스테이징에 올리는 작업과 커밋을 동시에 할 수 있습니다.(추적되지 않는 파일은 추가하지 않습니다.) -m을 사용하지 않을때 -v옵션을 사용하면 편집기에 커밋하려는 변경사항의 다른점을 보여줍니다. 특정파일만 커밋하려면 마지막에 파일명을 추가해주면 됩니다.

git commit -C HEAD -a --amend
지정한 커밋의 로그메시지를 다시 사용하여 기존커밋을 수정합니다. -c를 사용하면 기존메시지를 수정할 수 있는 편집기를 실행해 줍니다.

git status
커밋되지 않은 변경사항을 조회합니다.

git diff
스테이징영역과 현재 작업트리의 차이점을 보여줍니다. --cached 옵션을 추가하면 스테이징영역과 저장소의 차이점을 볼 수 있다. git diff HEAD를 입력하면 저장소, 스테이징영역, 작업트리의 차이점을 모두 볼 수 있다. 파라미터로 log와 동일하게 범위를 지정할 수 있으며 --stat를 추가하면 변경사항에 대한 통계를 볼 수 있습니다.

git mv 파일명 새파일명
기존에 존재하는 파일을 새파일로 이동합니다. 변경이력은 그대로 유지합니다.

git checkout -- 파일명
아직 스테이징이나 커밋을 하지 않은 파일의 변경내용을 취소하고 이전 커밋상태로 돌립니다. svn에서 revert와 동일합니다.




Branch와 Tag
git branch
현재 존재하는 브랜치를 조회합니다. -r 옵션을 사용하면 원격저장소의 브랜치를 확인할 수 있습니다.

git branch 브랜치명B 브랜치명A
브랜치명A에서 새로운 브랜치 브랜치명B를 만듭니다. (git에서 기본 브랜치는 master라는 이름을 사용합니다.)

git branch 브랜치명
브랜치명의 새로운 브랜치를 만듭니다.(체크아웃은 하지 않습니다.)

git branch -d 브랜치명
브랜치를 삭제합니다.

git branch -m 존재하는브랜치명 새로운브랜치명
존재하는 브랜치를 새로운브랜치로 변경합니다. 이미 존재하는 브랜치명이 있을 경우에는 에러가 나는데 -M 옵션을 사용하면 이미 있는 브랜치의 경우에도 덮어씁니다.

git tag 태그명 브랜치명
브랜치명의 현재시점에 태그명으로 된 태그를 붙힙니다. git tag만 입력하면 현재 존재하는 태그 목록을 볼 수 있습니다.

git checkout 브랜치명/태그명
해당 브랜치나 태그로 작업트리를 변경합니다.

git checkout -b 브랜치명B 브랜치명A
브랜치명A에서 브랜치명B라는 새로운 브랜치를 만들면서 체크아웃을 합니다.

git rebase 브랜치명
브랜치명의 변경사항을 현재 브랜치에 적용합니다.

git merge 브랜치명
브랜치명의 브랜치를 현재 브랜치로 합칩니다. --squash 옵션을 주면 브랜치명의 모든 커밋을 하나의 커밋으로 만듭니다.

git cherry-pick 커밋명
커밋명의 특정 커밋만을 선택해서 현재 브랜치에 커밋으로 만듭니다. -n 옵션을 주면 작업트리에 합치지만 커밋은 하지 않기 때문에 여러개의 커밋을 합쳐서 커밋할 수 있습니다.




로그 관리
git log
커밋로그들을 볼 수 있으면 -1나 -2같은 옵션을 주어 출력할 커밋로그의 갯수를 지정할 수 있습니다. --pretty=oneline 옵션을 주면 한줄로 간단히 보여주고 --pretty=format:"%h %s"처럼 형식을 정해줄 수 있습니다. -p 옵션을 사용하면 변경된 내용을 같이 보여줍니다. --since="5 hours" 이나 --before="5 hours"같은 옵션도 사용가능합니다. --graph 옵션을 주면 브랜치 트리를 볼 수 있습니다.

git log 커밋명
해당 커밋명의 로그를 볼 수 있습니다. 커밋명A..커밋명B (마침표2개)와 같이 입력하면 커밋명A이후부터 커밋명B까지의 로그를 볼 수 있습니다. ^은 -1과 동일해서 HEAD^라고 하면 최신바로 이전 커밋이고 HEAD^^^와 같이 쓸 수 있으며 HEAD~3을 하면 HEAD의 3개 이전의 커밋을 뜻합니다.

git blame 파일명
갈 줄 앞에 커밋명과 커밋한 사람등의 정보를 볼 수 있습니다.

git blame -L 10,15 파일명
-L 옵션을 사용하면 10줄부터 15줄로 범위를 지정해서 볼수 있고 15대신 +5와 같이 사용할 수 있습니다. 숫자의 범위 대신 정규식도 사용이 가능합니다.

git blame -M 파일명
-M 옵션을 사용하면 반복되는 패턴을 찾아서 복사하거나 이동된 내용을 찾아줍니다.  -C -C 옵션을 사용하면 파일간의 복사한 경우를 찾아줍니다. -C -C는 git log에서도 사용가능하며 내용의 복사를 찾을때는 git log에서 -p옵션을 사용합니다.

git revert 커밋명
기존의 커밋에서 변경한 내용을 취소해서 새로운 커밋을 만듭니다. -n옵션을 사용하면 바로 커밋하지 않기 때문에 revert를 여러번한 다음에 커밋할 수 있습니다.(항상 최신의 커밋부터 revert해야 합니다.)

git reset 커밋명
이전 커밋을 수정하기 위해서 사용합니다. --soft 옵션을 사용하면 이전 커밋을 스테이징하고 커밋은 하지 않으며 --hard옵션은 저장소와 작업트리에서 커밋을 제거합니다. git reset HEAD^와 같이 입력하면 최근 1개의 커밋을 취소할 수 있습니다.

git rebase -i 커밋범위
-i옵션으로 대화형모드로 커밋 순서를 변경하거나 합치는 등의 작업을 할 수 있습니다.




원격저장소
git clone 저장소주소 폴더명
원격저장소를 복제하여 저장소를 생성합니다. 폴더명을 생략가능합니다.

git fetch
원격저장소의 변경사항 가져와서 원격브랜치를 갱신합니다.

git pull
git fetch에서 하는 원격저장소의 변경사항을 가져와서 지역브랙치에 합치는 작업을 한꺼번에 합니다. 파라미터로 풀링할 원격저장소와 반영할 지역브랜치를 줄 수 있습니다.

git push
파라미터를 주지 않으면 origin 저장소에 푸싱하며 현재 지역브랜치와 같은 이름의 브랜치에 푸싱합니다. --dry-run 옵션을 사용하면 푸싱된 변경사항을 확인할 수 있습니다. 로컬에서 tag를 달았을 경우에 기본적으로 푸싱하지 않기 때문에 git push origin 태그명이나 모든 태그를 올리기 위해서 git push origin --tags를 사용해야 합니다.

git remote add 이름 저장소주소
새로운 원격 저장소를 추가합니다.

git remote
추가한 원격저장소의 목록을 확인할 수 있습니다.

git remote show 이름
해당 원격저장소의 정보를 볼 수 있습니다.

git remote rm 이름
원격저장소를 제거합니다.




서브모듈
git submodule
연관된 하위모듈을 확인할 수 있습니다.

git submodule add 저장소주소 서브모듈경로
새로운 하위모듈을 해당경로에 추가합니다. 추가만하고 초기화 하지는 않으며 커밋해쉬앞에 마이나스(-) 표시가 나타납니다.

git submodule init 서브모듈경로
서브모듈을 초기화 합니다.

git submodule update 서브모듈경로
서브모듈의 변경사항을 적용합니다.(저장소의 최신커밋을 추적하지 않습니다.)




기타 명령어
git archive --format=tar --prefix=폴더명/ 브랜치혹은태그 | gzip > 파일명.tar.gz
git archive --format=zip --prefix=폴더명/ 브랜치혹은태그 > 파일명.zip
해당 브랜치나 태그를 압축파일로 만듭니다. --prefix를 주면 압축하일이 해당폴더 안에 생성되도록 할 수 있습니다.

git mergetool
설정에 merge.tool의 값에 있는 머지툴을 찾아서 실행합니다.

git gc
저장소의 로그를 최적화 합니다. 로그가 변경되지는 않고 저장하는 방식만 최적화 합니다. --aggressive 옵션을 주면 더 자세하게 최적화합니다.

git rev-parse --show-toplevel
git 저장소내에서 입력하면 루트디렉토리를 알려줍니다.
// 참고 https://blog.outsider.ne.kr/572
