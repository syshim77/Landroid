
# 안드로이드 스튜디오 Day 4
기본위젯과 레이아웃

# 10강
기본위젯과 레이아웃(1)
화면을 만드는것이 중요한 이유는 화면단위로 움직이기 때문

1. 뷰와 뷰그룹
뷰
화면에 보이는 각각의 것들(버튼, 텍스트-액티비티라고 부른다)
화면을 구성하는 요소들

뷰그룹
뷰들을 여러새 포함하고 있는 것
모양은 없지만 특정 공간이 할당되어잇다.
뷰를 담고있는 그릇
뷰가 가지는 공간을 대체할 수 있다. (상속했기 때문)

위젯 (눈에 보임)
뷰 중에서 일반적인 컨트롤의 역할을 하는 것
버튼, 텍스트..

레이아웃
뷰의 위치를 정하는 것
배치를 정한다.
---

상속
내가 만든 액티비티는 Activity를 (안드로이드에서 제공하는 API) 상속하여 변수, 함수들을 그대로 가지고 있다.
___ extends ___
제공하는 것들을가져오거나 새로 만들어서 사용할 수 있다

뷰의 대표적인 속성
layout_width, layout_height

# 11강
기본위젯과 레이아웃(2)
app이라는 것은 모듈이다.
java 아래에는 소스 파일이 있고, res 에서 가장 중요한 것은 화면을 그려주는 xml이다.

RelativeLayout 태그 아래에 Button 태그가 있다.
xml아래에 들어가 있는 것을 속성이라고 한다.
"속성"
android: 라는 것은 무엇이냐하면 개발자들이 개발해 놓은 것들을 가져와서 쓰겠다는 것
배치하는 것이 layout

? Legacy와 layout의 차이?

layout_width와 layout_height가 있어야 화면 상의 공간을 할당받을 수 있음
id는 필수는 아니지만 각각을 구분해주는 구분자로서의 역할을 한다.
background 설정 : #__ __ __ __ RGB를 설정 가능 (맨 앞은 알파값)

<뷰의 대표적인 속성>
+ match_parent : 부모의 크기만큼 채운다
+ wrap_content : 내용물의 크기에 따라서 채운다
+ 값 고정도 가능 : ex) 200dp

+ id: 실제 기능을 동작시키는 것은 source. 메모리에 올라간 소스를 찾기위해 필요한것.

<뷰의 크기 지정에 사용되는 단위>
픽셀: 화면 해상도에 따른 단위. 해상도가 높은 화면에서는 작게보일 수 있다.
dp: 해상도에 따르지 않고 비율 단위로 계산해서 그려주는 것

<뷰의 id 속성>
xml 레이아웃에 있는 것을 source에서 기능을 부여하려면 찾아야한다.
(xml 레이아웃은 source가 아니므로)
()버튼이 어디에 만들어져있는지 모르기떄문에)
"@+id/button(이름)"에 들어가있다.

<뷰의 background 속성>
알파, 빨강, 그린, 파랑
ff -> 00 일수록 투명도가 높아진다.

# 12강
레이아웃(Linear Layout)

대표적인 레이아웃!?

스크롤뷰는 창보다 더 큰 화면이 필요할때 자동으로 스크롤이 나타난다.

#### <리니어 레이아웃>
layout attribute의 orientation에서 가로(horizontal)와 세로(vertical)를 정할 수 있다. 가로/세로의 한 방향으로만 채워진다.
리니어 레이아웃으로 버튼 여러개 만들어놓고 match_parent하면 다른 버튼들이 사라지기도 함 --> 주의!

#### gravity
버튼을 선택하고 gravity의 속성을 선택하면 버튼 안의 글자를 정렬할 수 있다.
그러나 wrap_content같은 속성처럼 여유공간이 주어지지 않으면 gravity는 효과가 없다.
(gravity는 여유공간이있어야하기때문)
##### layout_gravity
layout_gravity는 버튼이라는 위젯의 정렬을 할 수 있다. (가로/세로에 공간이 남아있어야 움직이는 것을 확인할 수 있고, match_parent를 썼다면 layout_gravity를 쓸 수 없다.)
일반 gravity는 위젯 안의 글자(내용)를 정렬한다.

wrap_content를 씌운 버튼에 layout_gravity가 적용이 되는것을 보아, 레이아웃을 나눈 공간은 해당 위젯이 사용하고있는 것이므로, 다른 버튼이 해당 공간을 침입할 수 없다는 것을 알 수 있다. (비어있는것처럼 보이지만 해당 가로/세로는 할당된 공간이다.)

# 13강
#### padding
원하는 위치에 padding을 줄 수 있다 (위젯의 내부에 여유 공간을 주는 것)
<안쪽>

#### Layout:margin
버튼이 다른 위젯들과 공간을 얼만큼 띄워줄지..
버튼내부가 아닌 외부에 적용되므로 layout이 붙는다.
<바깥쪽>

#### Layout:weight
가로/세로 match_parent의 속성을 가진 두개의 버튼이 있을때(아무옵션도 주지 않으면 하나가 다른 하나를 가린다.), 이 둘에 layout_weight를 1로 주었을 떄,
화면을 두개로 분할해준다.
두개를 각각 1, 2로 주면 1인 부분이 2/3의 크기를 가지는 화면을 얻게되고, 2인 버튼이 1/3의 화면크기를 가지게 된다.

# 14강
버튼 클릭의 이벤트 처리
방법1) 버튼선택->onClick속성에 이름 넣기(source코드에서 사용할 메소드의 이름 = 이 버튼이 클릭되었을떄 이 메소드를 호출해주세요~)

toast: 토스트 메시지는 아래에 잠시 나왔다가 사라지는 메시지를 말한다.
Toast.LENGTH_LONG: 메시지가 조금 길게 보여라~

방법2) 아이디을 사용. onCreate안에 find를 사용해..
HTML에서 클릭을 호출하고 자바에서 이를 처리하는 것과같이..(화면에 있는 것을 찾아내야한다.)
인플레이션: 화면에서 태그로 넣었던 것이 메모리에 올라간다.
--> 이 앱이 실행되었을 때, new로 새 버튼객체로 만들어주고, 이를 find로 찾고, Button 객체에 넣는다.
"Button Button2 = (Button)findViewById(R.id.button2);" 이런식으로 캐스팅해서 가져옴
위와같이 버튼을 찾으면 이벤트 처리를 해줄 수 있다.
리스너를 등록하면 표준 자바에서 이벤트가 발생할떄까지 대기하고 있는 것. 여기로 이벤트가 전달된다.
--> 여기서 글씨가 빨간색으로 변하는데, 이는 여러 onClickListener중에 무엇을 쓸지에 대해서 물어보고 싶어서 이다. 이떄 해당 줄의 다른 곳에 커서를 놓고 alt + enter을 누르면 몇개중에서 고를 수 있다.

xml버튼에 기능을 부여하려면 소스에 있는것이 아니기때문에 인플레이션(앱이 실행될때 자동으로 메모리에 올라간다.) 때문에 버튼이 어디있는지 알기 위해서 findviewid로 찾아주고, event를 처리하는 코드(setOnClickListener)를 넣으면(onClick 호출되어) 이벤트 처리 가능
setContentView : xml레이아웃을 지정해주면 해당 xml에 연결된다고 생각..?(첫 화면에 설정된다.) --> 이벤트 처리보다 더 아래에 넣으면 에러가 난다. (앱의 비정상 종료 - android ddms에서 볼 수 있음, no filters --> 에러 메시지를 볼 수 있다., causedby 확인)
--> 왜 에러가 나느냐하면 xml파일의 내용이 자바 소스코드에 붙기 위해서, 메모리에 올라가야하는데 이 과정을 하는 것이 setContentView이기떄문이다. 그래서 이 과정을 button찾기 전에 해야함. 왜냐면 setContentView 때 인플레이션이 일어나서 메모리있는 액티비티 메인을 찾을 수 있기때문이다.

*인플레이션 매우 중요*

알아낸 것
alt + enter 로 연관 어구 사용 가능
